This file contains a variety of practice problems from different websites. I found these the most helpful in my SQL learning journey as they gave me exposure to a variety of question
types/problems I could encounter as well as new SQL syntax I hadn't used before. I revisit these practice problems to brush up on my SQL skills. The difficulty of the problems is specified in headings.

HackerRank
Easy
Question: Query all columns for all American cities in the CITY table with populations larger than 100000. The CountryCode for America is USA.
Approach: We need to form a select statement with * to select all columns, gather the data from the city table, and filter using a where clause. There are two conditions, so include these both using the and operator.

select * from city
where population > 100000
and countrycode = 'USA'

Question: Query the NAME field for all American cities in the CITY table with populations larger than 120000. The CountryCode for America is USA.
Approach: We need to form a select statement and select the name column, gather the data from the city table, and filter using a where clause. There are two conditions, so include these both using the and operator.

select name from city
where population > 120000
and countrycode = 'USA'

Question: Query all columns (attributes) for every row in the CITY table
Approach: This is a straight forward select statement. We use * to select all the columns from the city table.

select * from city

Question: Query all columns for a city in CITY with the ID 1661.
Approach: We use a select statement with * to include all the columns. We filter using a where clause to the specified numerical value.

select * from city
where ID = 1661

Question: Query all attributes of every Japanese city in the CITY table. The COUNTRYCODE for Japan is JPN.
Approach: We use a select statement with * to include all the columns. We filter using a where clause to the specified countrycode.

select * from city
where countrycode = 'JPN'

Question: Query the names of all the Japanese cities in the CITY table. The COUNTRYCODE for Japan is JPN.
Approach: We can use the same answer from the previous question and modify it to select only the name column rather than all.

select name from city
where countrycode = 'JPN'

Question: Query a list of CITY and STATE from the STATION table.
Approach: This is a straight forward select statement. We select the city and state columns from the station table.

select city, state from station

Question: Query a list of CITY names from STATION for cities that have an even ID number. Print the results in any order, but exclude duplicates from the answer.
Approach: In order to exclude duplicates we use the distinct function. We select the city column from the station table. In order to get even number ids only we can use the modulo operator. The id number divided by 2 should give remainder 0.

select distinct city from station
where mod(id, 2) = 0

Question: Find the difference between the total number of CITY entries in the table and the number of distinct CITY entries in the table.
Approach: We select a count of the city names and subtract from a count of distinct city names from the station table.

select count(city) - count(distinct city) from station

Question: Query the two cities in STATION with the shortest and longest CITY names, as well as their respective lengths (i.e.: number of characters in the name). If there is more than one smallest or largest city, choose the one that comes first when ordered alphabetically.
Approach: We select city name from the station table and use the length function to get the number of letters in the city name. We order the results by length descending to get the longest name and also order by city to sort alphabetically. Limit to the top answer. We use a union to display the shortest city as well. We use the same select statement and change to ascending length.

(select city, length(city) from station
order by length(city) desc, city
limit 1)
union
(select city, length(city) from station
order by length(city) asc, city
limit 1)

Question: Query the list of CITY names starting with vowels (i.e., a, e, i, o, or u) from STATION. Your result cannot contain duplicates.
Approach: We use a distinct clause in order to avoid duplicates. We can match any of the characters in the brackets at the beginning of the string using an rlike expression, ^, and [].

select distinct city from station
where city RLIKE '^[AEIOU]'

Question: Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot contain duplicates.
Approach: We use a distinct clause in order to avoid duplicates. We can match any of the characters in the brackets at the end of the string using an rlike expression, $, and [].

select distinct city from station
where city RLIKE '[aeiou]$'

Question: Query the list of CITY names from STATION which have vowels (i.e., a, e, i, o, and u) as both their first and last characters. Your result cannot contain duplicates.
Approach: We can combine some of the previous select statements from previous questions with an and operator in order to satisfy both conditions.

select distinct city from station
where city rlike '^[AEIOU]' and city rlike '[aeiou]$'

Question: Query the list of CITY names from STATION that do not start with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the first letter and add not to the rlike operator in order to search for the opposite.

select distinct city from station
where city not RLIKE '^[AEIOU]'

Question: Query the list of CITY names from STATION that do not end with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the last letter and add not to the rlike operator in order to search for the opposite.

select distinct city from station
where city not RLIKE '[aeiou]$'

Question: Query the list of CITY names from STATION that either do not start with vowels or do not end with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the first and last letter and add not to the rlike operator in order to search for the opposite. We also edit the epression to or instead of and to serach for either.

select distinct city from station
where city not rlike '^[AEIOU]' or city not rlike '[aeiou]$'

Question: Query the list of CITY names from STATION that do not start with vowels and do not end with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the first and last letter and add not to the rlike operator in order to search for the opposite.

select distinct city from station
where city not rlike '^[AEIOU]' and city not rlike '[aeiou]$'

Question: Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
Approach: We select the column name from the table students. We filter to marks greater than 75. To order by the last 3 characters of the names we use the substring function specifying the name column, the third to last position of the string, and 3 characters from this position i the string. We then order by ascending id.

select name from students
where marks > 75
order by substring(name, -3, 3), id asc

Question: Write a query that prints a list of employee names (i.e.: the name attribute) from the Employee table in alphabetical order.
Approach: We select the name column from the employee table. We then order by name to put the names in alphabetical order.

select name from employee
order by name

Question: Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.
Approach: We select the name column from the employee table. We filter to salary over 2000 and months less than 10. We lastly order by ascending employee id.

select name from employee
where salary > 2000
and months < 10
order by employee_id asc

Question: Write a query identifying the type of each record in the TRIANGLES table using its three side lengths. Output one of the following statements for each record in the table:
Equilateral: It's a triangle with 3 sides of equal length.
Isosceles: It's a triangle with 2 sides of equal length.
Scalene: It's a triangle with 3 sides of differing lengths.
Not A Triangle: The given values of A, B, and C don't form a triangle.
Approach: We use a case statement in order to create a new column and print the desired text. The case statement conditions are evaluated in order so we should first determine if the sides even make up a triangle. From there we can test if all sides are equal, then if two sides are equal, or if none are equal.

SELECT
  CASE 
    WHEN A + B <= C or A + C <= B or B + C <= A THEN 'Not A Triangle'
    WHEN A = B and B = C THEN 'Equilateral'
    WHEN A = B or A = C or B = C THEN 'Isosceles'
    WHEN A <> B and B <> C THEN 'Scalene'
  END AS triangle_type
FROM TRIANGLES;

Question: Query a count of the number of cities in CITY having a Population larger than 100,000
Approach: We use the count(*) function to count the total number of results. We then filter the population number using a where clause.

select count(*) from city
where population > 100000

Question: Query the total population of all cities in CITY where District is California.
Approach: We use the count function and specify the population column in order to get the aggregate population. We filter the district to California using a where clause.

select sum(population) from city
where district = 'California'

Question: Query the average population of all cities in CITY where District is California.
Approach: We can use the select statement from the previous question and change the sum function to the avergae function instead.

select avg(population) from city
where district = 'California'

Question: Query the average population for all cities in CITY, rounded down to the nearest integer.
Approach: We use the average function to get the average population from the city table. We use the floor funtion on the average function to round down to the nearest integer.

select floor(avg(population)) from city

Questiion: Query the sum of the populations for all Japanese cities in CITY. The COUNTRYCODE for Japan is JPN
Approach: We use the sum function and specify the population column in order to get the aggregate population. We filter the countrycode to Japan using a where clause.

select sum(population) from city
where countrycode = 'JPN'

Question: Query the difference between the maximum and minimum populations in CITY.
Approach: We use the max and min functions ad specify the population column. We subtract these from each other to obtain our result.

select max(population) - min(population) from city

Question: Samantha was tasked with calculating the average monthly salaries for all employees in the EMPLOYEES table, but did not realize her keyboard's  key was broken until after completing the calculation. She wants your help finding the difference between her miscalculation (using salaries with any zeros removed), and the actual average salary. Write a query calculating the amount of error (i.e.:  average monthly salaries), and round it up to the next integer.
Approach: We start by using av(salary) to get the actual result. In order to achieve the result of the miscalculation we need to replace every instance of 0 with an empty value. We do this by using the replace function. We then subract these two results (actual and miscalculation) and use the ceil function to round up.

select ceil(avg(salary) - avg(replace(salary, 0, ''))) from employees

Question: We define an employee's total earnings to be their monthly salary * months worked, and the maximum total earnings to be the maximum total earnings for any employee in the Employee table. Write a query to find the maximum total earnings for all employees as well as the total number of employees who have maximum total earnings. Then print these values as 2 space-separated integers.
Approach: We use the max function of months*salary to get the maximum value of total earnings. We use a count(*) function to determine the total number of employees with the max total_earnings as their total earnings. We use a subquery in order to specify the value we want the count to retrieve.

SELECT MAX(months * salary), COUNT(*) 
FROM employee
WHERE months * salary = (SELECT MAX(months * salary) FROM employee)

Question: Query the following two values from the STATION table:
The sum of all values in LAT_N rounded to a scale of 2 decimal places.
The sum of all values in LONG_W rounded to a scale of 2 decimal places.
Approach: we use the round function on the sum of latitude and longitude values to round the results to 2 decimal places.

select round(sum(lat_n), 2), round(sum(long_w), 2) from station

Question: Query the sum of Northern Latitudes (LAT_N) from STATION having values greater than 38.7880 and less than 137.2345. Truncate your answer to  decimal places.
Approach: We use the truncate function on the sum of lat_n to truncate the answer to 4 decimal places. We use the between operator in order to specify the numeric boundaries.

select truncate(sum(lat_n), 4) from station
where lat_n between 38.7880 and 137.2345

Question: Query the greatest value of the Northern Latitudes (LAT_N) from STATION that is less than 137.2345. Truncate your answer to 4 decimal places.
Approach: We use the truncate function on lat_n to truncate the answer to 4 decimal places. We use a where clause in order to filter the results to less than 137.2345. We then order the results by descending lat_n and limit to 1 in order to get the top value.

select truncate(lat_n, 4) from station
where lat_n < 137.2345
order by lat_n desc
limit 1

Question: Query the Western Longitude (LONG_W) for the largest Northern Latitude (LAT_N) in STATION that is less than 137.2345. Round your answer to 4 decimal places.
Approach: We use the round function on long_w to round the answer to 4 decimal places. We use a where clause in order to filter the results to lat_n less than 137.2345. We then order the results by descending lat_n and limit to 1 in order to get the top value.

select round(long_w, 4) from station
where lat_n < 137.2345
order by lat_n desc
limit 1

Question: Query the smallest Northern Latitude (LAT_N) from STATION that is greater than 38.7780. Round your answer to 4 decimal places.
Approach: We use the round function on lat_n to round the answer to 4 decimal places. We use a where clause in order to filter the results to greater than 38.7780. We then order the results by ascending lat_n and limit to 1 in order to get the smallest value.

select round(lat_n, 4) from station
where lat_n > 38.7780
order by lat_n asc
limit 1

Question: Query the Western Longitude (LONG_W)where the smallest Northern Latitude (LAT_N) in STATION is greater than 38.7780. Round your answer to 4 decimal places.
Approach: We use the round function on long_w to round the answer to 4 decimal places. We use a where clause in order to filter the results to greater than 38.7780. We then order the results by ascending lat_n and limit to 1 in order to get the smallest value.

select round(long_w, 4) from station
where lat_n > 38.7780
order by lat_n asc
limit 1

Question: Given the CITY and COUNTRY tables, query the sum of the populations of all cities where the CONTINENT is 'Asia'.
Approach: We need to join the city and country tables in order to use data from both tables. We select the sum of population specifying it is from the city table. We use an inner join in order to match values in both the city and country tables. We join on their common column country code. Lastly, we filter the results using a where clause and set the continent to Asia.

select sum(city.population) from city
inner join country on city.countrycode = country.code
where country.continent = 'Asia'

Question: Given the CITY and COUNTRY tables, query the names of all cities where the CONTINENT is 'Africa'.
Approach: We need to join the city and country tables in order to use data from both tables. We select the name column specifying it is from the city table. We use an inner join in order to match values in both the city and country tables. We join on their common column country code. Lastly, we filter the results using a where clause and set the continent to Africa.

select city.name from city
inner join country on city.countrycode = country.code
where country.continent = 'Africa'

Question: Given the CITY and COUNTRY tables, query the names of all the continents (COUNTRY.Continent) and their respective average city populations (CITY.Population) rounded down to the nearest integer.
Approach: We need to join the city and country tables in order to use data from both tables. We select the contient column specifying it is from the country table. We also select the average population specifying it is from the city table and use the floor function on this result in order to round down to the nearest integer. We use an inner join in order to match values in both the city and country tables. We join on their common column country code. Lastly, we group by country.continent to specify the average aggregations.

select country.continent, floor(avg(city.population)) from city
inner join country on city.countrycode = country.code
group by country.continent

Medium
Question: Generate the following two result sets:

Query an alphabetically ordered list of all names in OCCUPATIONS, immediately followed by the first letter of each profession as a parenthetical (i.e.: enclosed in parentheses). For example: AnActorName(A), ADoctorName(D), AProfessorName(P), and ASingerName(S).
Query the number of ocurrences of each occupation in OCCUPATIONS. Sort the occurrences in ascending order, and output them in the following format:

There are a total of [occupation_count] [occupation]s.
where [occupation_count] is the number of occurrences of an occupation in OCCUPATIONS and [occupation] is the lowercase occupation name. If more than one Occupation has the same [occupation_count], they should be ordered alphabetically.
Approach: For the first result set, we use the concatenate function to print out the name, parenthesis, and use the substring function to extract the first letter in the occupation column. We use an alias N for this concatenated string in order to sort later since using a union will order the entire result set when an order by function is used. We use a union and move on the the next result set. For this result we again use the concatenated function to print out the given string, then a count of each occupation, a space, the occupation in lowercase, and an s. We also use the alias N for sorting purposes. We group by occupation since we used the count function. Lastly, we sort the entire union by N asc. This will sort the first part alphabetically and the second part numerically ascending.

(select concat(name, '(', substr(Occupation,1,1), ')') as N from occupations)
union
(select concat('There are a total of ', count(occupation), ' ', lower(occupation), 's.') as N from occupations
group by occupation)

order by N asc

Question: Amber's conglomerate corporation just acquired some new companies. Each of the companies follows this hierarchy: Founder > Lead Manager > Senior Manager > Manager > Employee. Given the table schemas below, write a query to print the company_code, founder name, total number of lead managers, total number of senior managers, total number of managers, and total number of employees. Order your output by ascending company_code.
Approach: After browsing the table schemas we notice that The employee and company tables include all the data we need. The rest of the tables contain redundant information. We select company_code from the employee table, founder name from the company table, a count of the distinct lead manager codes from the employee table, a count of the distinct senior manager codes from the employee table, a count of the distinct manager codes from the employee table, and a count of the distinct employee codes from the employee table. We inner join on company_code to join the employee and company tables using the aliases e and c respectively. We gorup by company code and founder since these are out non-aggregates. Lastly, we order by ascending company code.

select 
e.company_code, 
c.founder, 
count(distinct e.lead_manager_code), 
count(distinct e.senior_manager_code), 
count(distinct e.manager_code), 
count(distinct e.employee_code) 
from employee e
inner join company c 
on e.company_code = c.company_code
group by e.company_code, c.founder
order by e.company_code asc

Question: You are given a table, BST, containing two columns: N and P, where N represents the value of a node in Binary Tree, and P is the parent of N. Write a query to find the node type of Binary Tree ordered by the value of the node. Output one of the following for each node:
Root: If node is root node.
Leaf: If node is leaf node.
Inner: If node is neither root nor leaf node.
Approach: In order to satisfy the desired output, we will need the value of n, whether the node is a root, leaf or inner, ordered by n. To do this we first select n. Then we construct a case statement. We can start with the simplest condition which is for a root node. If the value of P is null (no parent node), the node is a root. Next, if the node is an inner node the value of n will also be inside p because the node can also be a parent node. All other values of n will be considered leaves.

select n,
case 
when p is null then 'Root'
when n in(select p from bst) then 'Inner'
else 'Leaf'
end as 'type of node'
from bst
order by n

Question: Consider P1 and P2 to be two points on a 2D plane.
 a happens to equal the minimum value in Northern Latitude (LAT_N in STATION).
 b happens to equal the minimum value in Western Longitude (LONG_W in STATION).
 c happens to equal the maximum value in Northern Latitude (LAT_N in STATION).
 d happens to equal the maximum value in Western Longitude (LONG_W in STATION).
Query the Manhattan Distance between points P1 and P2 and round it to a scale of 4 decimal places.
Approach: The formula for Manhattan Distance is |x1 - x2| + |y1 - y2|. We can replace these values with our given ones to get |a - c| + |b - d|. We then plug in the values to get |min(lat_n) - max(lat_n)| + |min(long_w) - max(long_w)|. In order to input to sql we use the abs() function. Lastly we use the round function to round to 4 decimal places.

select round((abs(min(lat_n)-max(lat_n)) + abs(min(long_w)-max(long_w))),4) from station

Question:
Consider p1(a,c) and p2(b,d) to be two points on a 2D plane where (a,b) are the respective minimum and maximum values of Northern Latitude (LAT_N) and (b,d) are the respective minimum and maximum values of Western Longitude (LONG_W) in STATION. Query the Euclidean Distance between points p1 and p2 and format your answer to display 4 decimal digits.
Approach: The formula for Euclidean Distance is sqrt((q1-p1)^2 + (q2-p2)^2). We can replace these values with our given ones to get sqrt((b-a)^2 + (d-c)^2). We then plug in the values to get sqrt((max lat_n-min lat_n)^2 + (max long_w-min long_w)^2). In order to input to sql we use the power() and sqrt() functions. Lastly we use the round function to round to 4 decimal places.

select round((sqrt(
power((max(lat_n) - min(lat_n)), 2) +
power((max(long_w) - min(long_w)),2)
    )), 4)
from station

Question: A median is defined as a number separating the higher half of a data set from the lower half. Query the median of the Northern Latitudes (LAT_N) from STATION and round your answer to 4 decimal places.
Approach: We first need to order the lat_n values. To do this, we can use a cte which we will name in_order. Within this cte, we select the let_n column and window functions to add numbered columns for both ascending lat_n and descending lat_n. Our goal with this is to find the matching column number of the ascending and descending values, or the average if there is an even number or values. To do this, we select from the cte the averge lat_n rounded to 4 decimal places that satisfies the condition ascending row number = descending row number, or one above or below. This should give us our median value. 

with in_order as (
SELECT lat_n,
ROW_NUMBER() OVER (ORDER BY lat_n) AS RowAsc,
ROW_NUMBER() OVER (ORDER BY lat_n DESC) AS RowDesc
FROM station
)

SELECT round((AVG(lat_n)), 4) AS median
FROM in_order
WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1;

Question: You are given two tables: Students and Grades. Students contains three columns ID, Name and Marks. Ketty gives Eve a task to generate a report containing three columns: Name, Grade and Mark. Ketty doesn't want the NAMES of those students who received a grade lower than 8. The report must be in descending order by grade -- i.e. higher grades are entered first. If there is more than one student with the same grade (8-10) assigned to them, order those particular students by their name alphabetically. Finally, if the grade is lower than 8, use "NULL" as their name and list them by their grades in descending order. If there is more than one student with the same grade (1-7) assigned to them, order those particular students by their marks in ascending order. Write a query to help Eve.
Approach: Because we want to treat 2 result sets differently, we know we will use a case statement. The condition we will use is grade < 8 to print null. Otherwise, the student's name will be printed. We specify the end as columns name, grade, and marks. The name column is not the same as s.name since we are using the nulls, so we just say 'name'. We use an inner join to join the students table to the grades table. Since the grades table has a range of values within 2 columns we use between in our on condition. Lastly, we order by grade descending, then by name alphabetically, then by ascending marks.

select 
case 
when g.grade < 8 then null
else s.name
end as name, g.grade, s.marks from students s
inner join grades g 
on s.marks between g.min_mark and g.max_mark
order by g.grade desc, s.name, s.marks asc

Question: Julia just finished conducting a coding contest, and she needs your help assembling the leaderboard! Write a query to print the respective hacker_id and name of hackers who achieved full scores for more than one challenge. Order your output in descending order by the total number of challenges in which the hacker earned a full score. If more than one hacker received full scores in same number of challenges, then sort them by ascending hacker_id.
Approach: We first select hacker_id from the submissions table and name from the hackers table. We will need to join all the tables on common columns. To filter for full scores, we need to make sure the score earned by the hacker in the submissions table is the same as the total possible score from tthe difficulty table and also that the score pertains to the difficulty level for that particular challenge. We group by hacker_id and name to narrow to one row per hacker and use a count function to filter to those gaining a full score in more than 1 challenge. Lastly, we order by the number of challenges and by hacker_id.

select s.hacker_id, h.name from submissions s
inner join hackers h
on h.hacker_id = s.hacker_id
inner join challenges c
on c.challenge_id = s.challenge_id
inner join difficulty d
on d.difficulty_level = c.difficulty_level
where d.score = s.score and d.difficulty_level = c.difficulty_level
group by s.hacker_id, h.name
having count(h.name) > 1
order by count(h.name) desc, s.hacker_id

Question: Harry Potter and his friends are at Ollivander's with Ron, finally replacing Charlie's old broken wand. Hermione decides the best way to choose is by determining the minimum number of gold galleons needed to buy each non-evil wand of high power and age. Write a query to print the id, age, coins_needed, and power of the wands that Ron's interested in, sorted in order of descending power. If more than one wand has same power, sort the result in order of descending age.
Approach: We use the desired columns id, age, coins_needed, and power in the select statement and inner join the wands table to the wands property table on the column code. To filter our results to the minimum number of coins needed we use a where clause and an additional select statement within this clause with the same joins. We need to use a different alias for the self joins. Then we can use a where clause to filter to only non-evil wands and set tthe ages and power equal to each other in order to get the best results for these. We lastly order by descending power and descending age.

select w.id, p.age, w.coins_needed, w.power from wands w
inner join wands_property p
on w.code = p.code
where coins_needed = (select (min(coins_needed)) from wands w2
inner join wands_property p2
on w2.code = p2.code
where p2.is_evil = 0
and p.age = p2.age
and w.power = w2.power) 
order by w.power desc, p.age desc

Question: Julia asked her students to create some coding challenges. Write a query to print the hacker_id, name, and the total number of challenges created by each student. Sort your results by the total number of challenges in descending order. If more than one student created the same number of challenges, then sort the result by hacker_id. If more than one student created the same number of challenges and the count is less than the maximum number of challenges created, then exclude those students from the result.
Approach: We first include our desired columns hacker id, name and a count of the challenges. We join the challenges and hackers table on hackerid for the desired information. We group by hackerid and name since we used the count function and want the totals for each hacker. We can break the desired result set into two parts. In the first part, we want to include all the students with the highest number of challenges created. For this, we use a having clause for the count of challenges and set it equal to a subquery of the highest count of challenges. For the second part, we want to include the counts without duplicates. To do this we use another subquery in which we select the count of challenges having unique values when compared to the original count, excluding matching hacker_ids. Lastly, we order the results by descending totals, and hacker id.

select c.hacker_id, h.name, count(c.challenge_id) from challenges c
inner join hackers h
on c.hacker_id = h.hacker_id
group by c.hacker_id, h.name
having count(c.challenge_id) = 
(select count(c1.challenge_id) from challenges as c1 
group by c1.hacker_id 
order by count(*) desc
limit 1) 
or
count(c.challenge_id) not in 
(select count(c2.challenge_id) from challenges as c2
group by c2.hacker_id 
having c2.hacker_id <> c.hacker_id)
order by count(c.challenge_id) desc, hacker_id

Question: You did such a great job helping Julia with her last coding contest challenge that she wants you to work on this one, too! The total score of a hacker is the sum of their maximum scores for all of the challenges. Write a query to print the hacker_id, name, and total score of the hackers ordered by the descending score. If more than one hacker achieved the same total score, then sort the result by ascending hacker_id. Exclude all hackers with a total score of 0 from your result.
Approach: The first step is to find the maximum scores for all the challenges. In order to do this we use a select statement selecting the columns hackerid, challenge is and the maximum of the score column from the submissions table and group by hacker is and challenge id in order to get the maximum score per challenge per hacker. This becomes our inner query so we can then select the sum of the max scores per hacker, as well as the hackerid and name columns. In order to use the name column we need to perform an inner join with the hackers table on hacker id. We group the results by our non-aggregate columns hackerid and name. Then we filter our results to those having totalscores greater than 0 and lastly we order bytotalscore descending and hackerid.

select ms.hacker_id, h.name, sum(max_score) as totalscore from
(select hacker_id, challenge_id, max(score) as max_score from submissions 
group by hacker_id, challenge_id) as ms
inner join hackers h
on ms.hacker_id = h.hacker_id
group by ms.hacker_id, h.name
having totalscore > 0
order by totalscore desc, ms.hacker_id

Question: You are given a table, Projects, containing three columns: Task_ID, Start_Date and End_Date. It is guaranteed that the difference between the End_Date and the Start_Date is equal to 1 day for each row in the table. If the End_Date of the tasks are consecutive, then they are part of the same project. Samantha is interested in finding the total number of different projects completed. Write a query to output the start and end dates of projects listed by the number of days it took to complete the project in ascending order. If there is more than one project that have the same number of completion days, then order by the start date of the project.
Approach: We wante to remove the overlapping days in between start and end days in order to get the individual project start and end dates. To do this we can create a cte selecting start date, use a window function to order the dates and number the rows and exclude values in the end dates column. We do similarly for end dates. The ordering of the dates and numbering of the rows ensures that the project start date will line up with the proper end date. We then join the ctes on row number and order by the project days and start dates.

with sd as 
(select Start_Date, 
row_number() over(order by start_date) as rw from Projects 
where Start_date not in (select End_Date from Projects))
,
ed as 
(select End_Date, row_number() over(order by end_date) as rw from Projects 
where End_date not in (select Start_Date from Projects))

select sd.Start_Date, ed.End_Date from sd 
inner join ed 
on sd.rw = ed.rw
order by datediff(ed.End_Date, sd.Start_Date), sd.Start_Date

Question: You are given three tables: Students, Friends and Packages. Students contains two columns: ID and Name. Friends contains two columns: ID and Friend_ID (ID of the ONLY best friend). Packages contains two columns: ID and Salary (offered salary in $ thousands per month). Write a query to output the names of those students whose best friends got offered a higher salary than them. Names must be ordered by the salary amount offered to the best friends. It is guaranteed that no two students got same salary offer.
Approach: We first need to create a joined table with the necessary salary information. We start by joining packages to students on id in order to get the student salaries next to their ids and names. We then join friends on id as well to this combined table to add the id of each student's best friend. Lastly, we join packages again, this time on the best friend id in order to get a column of best friend salaries. We can now use a where clause to filter by best friend salary larger than student salary and order by best friend salary.

select s.name from students s
inner join packages p1
on s.id = p1.id
inner join friends f
on s.id = f.id
inner join packages p2
on f.friend_id = p2.id
where p2.salary > p1.salary
order by p2.salary

Question: Pivot the Occupation column in OCCUPATIONS so that each Name is sorted alphabetically and displayed underneath its corresponding Occupation. The output column headers should be Doctor, Professor, Singer, and Actor, respectively. Note: Print NULL when there are no more names corresponding to an occupation. Occupation will only contain one of the following values: Doctor, Professor, Singer or Actor.
Approach: We first create a cte to order the data. We add the column row_num using a window function which assigns row numbering which starts over for every new occupation with the names ordered alphabetically per occupation. Using this cte, we use case statements to display the names of each occupation, or a null value if there are no more names uder that occupation. The min function applied to these case statements in order to aggregate the row numbers. We establish the column names per min case statement. Lastly, grouping the results by row_num will give all the names per occupation per row number.

with ordered as 
(select name, occupation,
 row_number() over (partition by Occupation order by Name) as row_num
    from OCCUPATIONS
)

select 
    min(case when occupation = 'Doctor' then name else NULL end) as Doctor,
    min(case when occupation = 'Professor' then name else NULL end) as Professor,
    min(case when occupation = 'Singer' then name else NULL end) as Singer,
    min(case when occupation = 'Actor' then name else NULL end) as Actor
from ordered
group by row_num

StrataScratch
Easy

Question: Compare each employee's salary with the average salary of the corresponding department. Output the department, first name, and salary of employees along with the average salary of that department.
Approach: We first select the specified columns department, first name, and salary. In order to display average salary next to these values without aggregating, we use a window function to get the average salary per depatment.

select department, first_name, salary, avg(salary) over (partition by department) from employee

Question: Find the last time each bike was in use. Output both the bike number and the date-timestamp of the bike's last use (i.e., the date-time the bike was returned). Order the results by bikes that were most recently used.
Approach: There will be multiple logs for each bike so we will need to use a group by clause in order to get one result per bike. We select the bike number and use a max function on the end time to get the latest time. we group by bike_number then order by the max end time to get our result.

select bike_number, max(end_time) from dc_bikeshare_q1_2012
group by bike_number
order by max(end_time) desc

Question: Find the number of employees working in the Admin department that joined in April or later.
Approach: We use the count function in order to count the number of workers. We then limit the department to admin and the joining month to April or later.

select count(worker_id) from worker
where department = 'Admin'
and month(joining_date) >= 4 

Question: Find the number of workers by department who joined in or after April. Output the department name along with the corresponding number of workers. Sort records based on the number of workers in descending order.
Approach: We select the desired column department as well as use the count function for all rows (*) to count the number of workers. We use a where clause to filter the results to April or later using the month function on the column joining date. We then group  by department to get counts for each. And lastly, we order by the number of workers per depatment.

select department, count(*) from worker
where month(joining_date) >= 4
group by department
order by count(*) desc

Question: Find the average number of bathrooms and bedrooms for each city’s property types. Output the result along with the city name and the property type.
Approach: We select the columns city and property type and use the average function on the columns bathrooms and bedrooms. We group by city and then by property type to get average results for each category.

select city, property_type, avg(bathrooms), avg(bedrooms) 
from airbnb_search_details
group by city, property_type

Question: Find the details of each customer regardless of whether the customer made an order. Output the customer's first name, last name, and the city along with the order details.
You may have duplicate rows in your results due to a customer ordering several of the same items. Sort records based on the customer's first name and the order details in ascending order.
Approach: We select first name, last name, and city from the customers table and order detils from the orders table. We use a left join to join orders to customers in order to reatain all the records from customers regardless of if an order was made. We join on their common property customer id. Lastly, we order by first name and then order details.

select c.first_name, c.last_name, c.city, o.order_details from customers c
left join orders o
on c.id = o.cust_id
order by c.first_name, o.order_details asc

Question: Find the number of rows for each review score earned by 'Hotel Arena'. Output the hotel name (which should be 'Hotel Arena'), review score along with the corresponding number of rows with that score for the specified hotel.
Approach: We select hotel name, reviewer score and use the count function in order to count the number of rows of each review score. We specify the hotel name and then gorup by hotel name and review score to get our result.

select hotel_name, reviewer_score, count(*) 
from hotel_reviews
where hotel_name = 'Hotel Arena'
group by hotel_name, reviewer_score

Question: Count the number of movies that Abigail Breslin was nominated for an oscar.
Approach: We use a count function in order to count all rows for our conditions. We set the condition nominee = Abigail Breslin with a where clause to get out answer.

select count(*) from oscar_nominees
where nominee = 'Abigail Breslin'

Question: Write a query that returns the number of unique users per client per month
Approach: We use a count function to find the distinct number of users. We include and group by the columns client id and the month portion of time id in order to get our answer.

select count(distinct user_id), client_id, month(time_id) from fact_events
group by client_id, month(time_id)

Question: Count the number of user events performed by MacBookPro users. Output the result along with the event name. Sort the result based on the event count in the descending order.
Approach: We use the count function in order to count the total number of rows. We filter our results by device to include only macbook pro users. We group by event name to get counts per event in our answer. Lastly, we order by the counts descending.

select count(*), event_name from playbook_events
where device = 'macbook pro'
group by event_name
order by count(*) desc

Question: Find order details made by Jill and Eva. Consider the Jill and Eva as first names of customers. Output the order date, details and cost along with the first name. Order records based on the customer id in ascending order.
Approach: We select the desired columns and specify the tables they are from. We inner join the customers table to the orders table in order to retrieve the desired columns. We inner join on their common column customer id. We filter the results to only Jill and Eva's orders using a where clause. Lastly, we order by ascending customer id.

select c.first_name, o.order_date, o.order_details, o.total_order_cost from orders o
inner join customers c 
on c.id = o.cust_id
where c.first_name = 'Jill' or c.first_name = 'Eva'
order by o.cust_id asc

Question: Find the most profitable company from the financial sector. Output the result along with the continent.
Approach: We select the desired columns form the table. We filter he table to only incluse financial sector companies using a where clause. We then order by profits and limit to the top result to get our answer.

select company, continent from forbes_global_2010_2014
where sector = 'Financials'
order by profits desc
limit 1

Question: Find libraries who haven't provided the email address in circulation year 2016 but their notice preference definition is set to email.
Output the library code.
Approach: We select distinct library code to avoid dupliactes. We filter to the year 2016, email notice preferences, and no provided email address using where and and clauses.

select distinct home_library_code from library_usage
where circulation_active_year = 2016
and notice_preference_definition = 'email'
and provided_email_address = FALSE

Question: Find the activity date and the pe_description of facilities with the name 'STREET CHURROS' and with a score of less than 95 points.
Approach: We select the columns activity date and pe description. We use a where clause to filter to the facility name street churros and an and clause to filter to scores below 95.

select activity_date, pe_description from los_angeles_restaurant_health_inspections
where facility_name = 'STREET CHURROS'
and score < 95

Question: Find the base pay for Police Captains. Output the employee name along with the corresponding base pay.
Approach: We select the columns employee name and base pay from the table. We filter the results to include police captains by using a like operator and the terms captain and police.

select employeename, basepay from sf_public_salaries
where jobtitle like '%Captain%Police%'

Question: Write a query that calculates the difference between the highest salaries found in the marketing and engineering departments. Output just the absolute difference in salaries.
Approach: We first devise a query to retrieve the top salary from the marketing department. This is given by using the max function on the salary column, joining the employee and dept tables on departemnt id, and limiting the results to only the marketing department using a where clause. We repeat this query for the engineering department then select the adbsolute difference of these two queries.

select abs((select max(e.salary) from db_employee e
inner join db_dept d
on e.department_id = d.id
where d.department = 'marketing')
-
(select max(e.salary) from db_employee e
inner join db_dept d
on e.department_id = d.id
where d.department = 'engineering')
) as salary_diff

Question: Find how many times each artist appeared on the Spotify ranking list Output the artist name along with the corresponding number of occurrences. Order records by the number of occurrences in descending order.
Approach: We selct the artist as well as use a count function i order to count the number of instances each artist is on the list. We group by artist due to the aggregate count function and order by the count descending.

select artist, count(*) from spotify_worldwide_daily_song_ranking
group by artist
order by count(*) desc

Question: Find all Lyft drivers who earn either equal to or less than 30k USD or equal to or more than 70k USD. Output all details related to retrieved records.
Approach: We select * to retirve all columns from the table. We limit our results to less that or equal to 30k and greater than or equal to 70k using a where clause.

select * from lyft_drivers
where yearly_salary <= 30000 
or yearly_salary >= 70000

Question: We have a table with employees and their salaries, however, some of the records are old and contain outdated salary information. Find the current salary of each employee assuming that salaries increase each year. Output their id, first name, last name, department ID, and current salary. Order your list by employee ID in ascending order.
Approach: We select the desired columns ffrom the table. With the assumption that salaries increase each year, the current salary would be the maximum salary, so we include max(salary) in our columns. We group by the non-aggregate columns in order to get one result per person. Lastly, we order by id.

select id, first_name, last_name, department_id, max(salary) from ms_employee_salary
group by id, first_name, last_name, department_id
order by id

Question: Meta/Facebook has developed a new programing language called Hack. To measure the popularity of Hack they ran a survey with their employees. The survey included data on previous programing familiarity as well as the number of years of experience, age, gender and most importantly satisfaction with Hack. Due to an error location data was not collected, but your supervisor demands a report showing average popularity of Hack by office location. Luckily the user IDs of employees completing the surveys were stored.
Based on the above, find the average popularity of the Hack per office location. Output the location along with the average popularity.
Approach: We select the location column from the employees table and take the avg of popularity from the survey table. We inner join these two tables on their common column employee id. We group by locationin order to get one result per location.

select e.location, avg(hs.popularity) from facebook_employees e
inner join facebook_hack_survey hs
on e.id = hs.employee_id
group by e.location

Question: Write a query that will calculate the number of shipments per month. The unique key for one shipment is a combination of shipment_id and sub_id. Output the year_month in format YYYY-MM and the number of shipments in that month.
Approach: We use a concatenate function in order to format the date from the shapment date column. We select the year and hyphenate with month using the lpad fucntion to add zeros where necessary. We also include a column using the count function to count each rows as an order. We group by date to achieve a count per month.

select concat(year(shipment_date), '-', lpad(month(shipment_date), 2, '0')) as date, count(*) from amazon_shipment
group by date

Question: You have been asked to find the 5 most lucrative products in terms of total revenue for the first half of 2022 (from January to June inclusive). Output their IDs and the total revenue.
Approach: We calculate revenue per product id by taking the sum of cost*quantity sold. We filter the results to Jan through Jun by extracting the month from the date column. We group the results per product id. To retrive the top 5 we order the results by revenue descending and limit to 5 results. 

select product_id, sum(cost_in_dollars*units_sold) as rev from online_orders
where month(date) between '01' and '06'
group by product_id
order by rev desc
limit 5

Question: Find all posts which were reacted to with a heart. For such posts output all columns from facebook_posts table.
Approach: We select all distinct columns from the reactions table. We join the reactions table with the posts table and filter to a heart reaction with a where clause.

select distinct p.* from facebook_reactions r
inner join facebook_posts p
on r.post_id = p.post_id
where r.reaction = 'heart'

Medium
Question: Find the review_text that received the highest number of  'cool' votes. Output the business name along with the review text with the highest number of 'cool' votes.
Approach: We select the desired columns business name and review text from the table. We filter the results using a where clause and use a subquery to match the review text with the maximum cool rating.

select business_name, review_text from yelp_reviews 
where cool = (select max(cool) from yelp_reviews)

Question: Find the number of Apple product users and the number of total users with a device and group the counts by language. Assume Apple products are only MacBook-Pro, iPhone 5s, and iPad-air. Output the language along with the total number of Apple users and users with any device. Order your results based on the number of total users in descending order.
Approach: We first select language from our users table. To get the count for nly apple users we count the distinct instances where devices are either macbook pros, iphone 5s, or ipad air. We use a case function in order to only count the user ids with these devices. We then count all the user ids. We join the tables using user id as a common value. We lastly group the results by language and order by the total user counts descending.

select u.language, 
count(distinct case 
when e.device in ('macbook pro', 'iphone 5s', 'ipad air') then e.user_id
else null
end) as apple_users,
count(distinct e.user_id) as total_users
from playbook_events e
inner join playbook_users u on e.user_id = u.user_id
group by u.language
order by total_users DESC

Question: Output share of US users that are active. Active users are the ones with an "open" status in the table.
Approach: We need to calculate the ratio of users with open status in the united states to all users total within the united states. We can use a count and case statement to cunt those user ids where the status is open. We divide this by the count of total user ids. We filter both of these with a where clause to limit the results to usa. 

select 
count(case when status = 'open' then user_id else null end)/
count(user_id)
from fb_active_users
where country = 'USA'

Question: You are given a dataset that provides the number of active users per day per premium account. A premium account will have an entry for every day that it’s premium. However, a premium account may be temporarily discounted and considered not paid, this is indicated by a value of 0 in the final_price column for a certain day. Find out how many premium accounts that are paid on any given day are still premium and paid 7 days later.
Output the date, the number of premium and paid accounts on that day, and the number of how many of these accounts are still premium and paid 7 days later. Since you are only given data for a 14 days period, only include the first 7 available dates in your output.
Approach: We need to join the premium account table to itself in order to take the difference between the dates to include those spaced out by 7 days. We left join on this condition as well as if the final price is > 0 to retain all original table entries and math only those satisfying the conditions. We limit the original table to final price > 0 as well to only incluse paid accounts. We group by date. We order by this column as well and limit the entries to 7. lastly the columns we wish to include in our output are the date, counts of all account ids in the original table (all paid) and a count of the joined values (paid and paid again 7 days later)

select a.entry_date, count(a.account_id) premium_paid_accts, count(b.account_id) premium_paid_accts_7days from premium_accounts_by_day a
left join premium_accounts_by_day b
on a.account_id = b.account_id
and datediff(b.entry_date, a.entry_date) = 7
and b.final_price > 0
where a.final_price > 0
group by a.entry_date
order by a.entry_date
limit 7

Question: The election is conducted in a city and everyone can vote for one or more candidates, or choose not to vote at all. Each person has 1 vote so if they vote for multiple candidates, their vote gets equally split across these candidates. For example, if a person votes for 2 candidates, these candidates receive an equivalent of 0.5 vote each.
Find out who got the most votes and won the election. Output the name of the candidate or multiple names in case of a tie. To avoid issues with a floating-point error you can round the number of votes received by a candidate to 3 decimal places.
Approach: We first create a cte where a new column is added to assign the value 1 or 0 to a voter based on whether they voted or not. We also add a coulmn counting the number or people each voter voted for using a window function. Using this cte, we select the candidate with the most points by ordering by their cumulative points found using a sum function on the rounded result of vote binary (vote or no vote) / number or votes per voter.

with cte as (
SELECT
    voter,
    candidate,
    CASE
        WHEN candidate is null THEN 0
        ELSE 1
    END AS vote_binary, 
    count(candidate) OVER (PARTITION BY voter) AS number_of_votes
FROM 
    voting_results )
    
select candidate as candidate_votes from cte
group by candidate
order by sum(round(vote_binary/number_of_votes, 3)) desc
limit 1

Question: For each video, find how many unique users flagged it. A unique user can be identified using the combination of their first name and last name. Do not consider rows in which there is no flag ID.
Approach: We concatenate the first and last names in order to form a full name column. We count each distinct per flagged video. That is one wih flag id not null and group by video.

select count(distinct concat(user_firstname, ' ', user_lastname)), video_id 
from user_flags
where flag_id is not null
group by video_id

Question: Which user flagged the most distinct videos that ended up approved by YouTube? Output, in one column, their full name or names in case of a tie. In the user's full name, include a space between the first and the last name.
We first need to concatenate the first and last names.We do this by using the concatenate with seperator function and the coalesce function within to include null first and or last name values. We then join the two tables on their common columnflag id. We filter the results to approved by youtube. We group the results by user. To find the top users we order by the count of distinct videos flagged and limit to 2 since there is a tie.

select 
concat_ws(' ', coalesce(u.user_firstname, ''), coalesce(u.user_lastname, '')) as full_name
from user_flags u
inner join flag_review r
on u.flag_id = r.flag_id
where r.reviewed_outcome = 'APPROVED'
group by concat_ws(' ', coalesce(u.user_firstname, ''), coalesce(u.user_lastname, ''))
order by count(distinct u.video_id) desc
limit 2

Question: What were the top 10 ranked songs in 2010? Output the rank, group name, and song name but do not show the same song twice. Sort the result based on the year_rank in ascending order.
Approach: We select the desired columns from the table and specify distinct values so the songs dont repeat. We filter the results to 2010 only using a where clause. Then we order the results by rank and limit to 10 go get the top 10.

select distinct year_rank, group_name, song_name from billboard_top_100_year_end
where year = 2010
order by year_rank asc
limit 10

Question: Classify each business as either a restaurant, cafe, school, or other.
•	A restaurant should have the word 'restaurant' in the business name.
•	A cafe should have either 'cafe', 'café', or 'coffee' in the business name.
•	A school should have the word 'school' in the business name.
•	All other businesses should be classified as 'other'.
Output the business name and their classification.
Approach: In order to classify int groups, we use the case function. Using the case function we match the lowercase business names to the terms specified. The like operator with a % symbol on either side looks for that word in any part of the business name. Any left over unmatched business names are captured as other. To avoid duplicates we use distinct when selecting the business name column.

select distinct business_name,
case 
when lower(business_name) like "%restaurant%" then "restaurant"
when lower(business_name) like "%cafe%"
    or lower(business_name) like "%café%"
    or lower(business_name) like "%coffee%"
    then "cafe"
when lower(business_name) like "%school%" then "school"
else "other"
end as classification
from sf_restaurant_health_violations

Question: You're given a dataset of health inspections. Count the number of violation in an inspection in 'Roxanne Cafe' for each year. If an inspection resulted in a violation, there will be a value in the 'violation_id' column. Output the number of violations by year in ascending order.
Approach: We use the count function to count all rows and select the year portion of the inspection date column from the table. We filter the results to only roxanne cafe and where a violation was found. We lastly group the results by year in order to get a count per year.

select count(*), year(inspection_date) from sf_restaurant_health_violations
where business_name = "Roxanne Cafe"
and violation_id is not null
group by year(inspection_date)

Question: Find the rate of processed tickets for each type.
Approach: We can use a subquery to find the numberator in which processed is true. In the outer query, this number is divided by the total count and grouped per type.

select (select count(*) from facebook_complaints where processed = "TRUE")/count(*), type from facebook_complaints
group by type

Question: Calculate the total revenue from each customer in March 2019. Include only customers who were active in March 2019. Output the revenue along with the customer id and sort the results based on the revenue in descending order.
Approach: We select the customer id column along with the sum of order costs. We filter the results to March of 2019. We then group by customer to get order totals per customer. Latly, we order by these totals descending. 

select cust_id, sum(total_order_cost) from orders
where month(order_date) = 3 and year(order_date) = 2019
group by cust_id
order by sum(total_order_cost) desc

Question: Make a report showing the number of survivors and non-survivors by passenger class.
Classes are categorized based on the pclass value as:
pclass = 1: first_class
pclass = 2: second_classs
pclass = 3: third_class
Output the number of survivors and non-survivors by each class.
Approach: We select the pclass column to display the class, sum(survived) will give us the total number of survivors since this column is binary. We can calulate the number of non-survivers by taking the total count of passengers and subtracting the survivors. We lastly group by class to get totals per class.

select pclass,
        sum(survived) as survivors, 
        (count(*)- sum(survived)) as non_survivors  
        from titanic
group by pclass

Question: Find the second highest salary of employees.
Approach: We create a cte with a ranking of the salaries in descending order using the dense rank function. From the cte we select the salary with a ranking of 2.

with cte as (
select *,
dense_rank() over(order by salary desc) as salary_rank
from employee)
select salary from cte 
where salary_rank = 2

Question: Find employees who are earning more than their managers. Output the employee's first name along with the corresponding salary.
Approach: This table lists each employee with an id including managers, their salaries, and the id of their corresponding manager. We can join the table to itself in order to add columns for the manager's information on the same row as that of the employees. We join on the common field id and manager id. Then we filter the results to where employee salary is greater than manager salary.

select e1.first_name, e1.salary from employee e1
inner join employee e2
on e1.manager_id = e2.id
where e1.salary > e2.salary

Question: Find the employee with the highest salary per department. Output the department name, employee's first name along with the corresponding salary.
Approach: We can find the top salaries per department by using the max function on the salary column and grouping by department. We make this into a cte named max salaries in order to join this table to the original employees table on the condition salary = max salary.

with maxsalaries as
(select department as dept, max(salary) as maxsalary from employee
group by department)

select e.department, e.first_name, maxsalaries.maxsalary from employee e
inner join maxsalaries
on e.salary = maxsalaries.maxsalary

Question: Find the highest target achieved by the employee or employees who works under the manager id 13. Output the first name of the employee and target achieved. The solution should show the highest target achieved under manager_id=13 and which employee(s) achieved it.
Approach: We fist construct the subquery to select the max target from the table where manager 1d is 13. Then we construct the outer query in which we output the names and target numbers having manager id 13 and the max target number calculated in the subquery.

select first_name, target from salesforce_employees
where manager_id = 13
and target = (select max(target) from salesforce_employees
where manager_id = 13)

Question: Find the customer with the highest daily total order cost between 2019-02-01 to 2019-05-01. If customer had more than one order on a certain day, sum the order costs on daily basis. Output customer's first name, total cost of their items, and the date. For simplicity, you can assume that every first name in the dataset is unique.
Approach: We first need to join the tables on their common value customer id. We then pick our desired columns using the sum of total order cost inorder to aggregate these by person by day. We filter the results to our specified time fram using a where clause. We then group the results by first name and order date to get our desired sum. Lastly, we order by the sum or total order cost descending and limit the result to 1 to get the top spender.

select c.first_name, sum(o.total_order_cost), o.order_date from customers c
inner join orders o
on c.id = o.cust_id
where order_date between '2019-02-01' and '2019-05-01'
group by c.first_name, o.order_date
order by sum(o.total_order_cost) desc
limit 1

Question: Find the Olympics with the highest number of athletes. The Olympics game is a combination of the year and the season, and is found in the 'games' column. Output the Olympics along with the corresponding number of athletes.
Approach: We select the games column and  take a count of the unique ids per olymipcs to get a count of athletes. We group by games to get our desired count. Lastly, we order by the count descending and limit to 1 to get our top result. 

select games, count(distinct id) from olympics_athletes_events
group by games
order by count(distinct id) desc
limit 1

Question: Find songs that have ranked in the top position. Output the track name and the number of times it ranked at the top. Sort your records by the number of times the song was in the top position in descending order.
Approach: We select the trackname column and count the occurences of each trackname as well using the count function. We filter the results to where position is 1 and group by trackname. We order the results by number of times at the top descending.

select trackname, count(trackname) from spotify_worldwide_daily_song_ranking
where position = 1
group by trackname
order by count(trackname) desc

Question: Find all wineries which produce wines by possessing aromas of plum, cherry, rose, or hazelnut. To make it more simple, look only for singular form of the mentioned aromas. HINT: if one of the specified words is just a substring of another word, this should not be a hit, but a miss.
Example Description: Hot, tannic and simple, with cherry jam and currant flavors accompanied by high, tart acidity and chile-pepper alcohol heat.
Therefore the winery Bella Piazza is expected in the results.
Approach: We select the winery column and specify discinct so that there are no repetitions. We use a where clause to filter our results. The description column is converted to lowercase to account for any use of the word, capital or lowercase. We use the regexp to match any of the descriptive words followed by a non lowercase letter.

select distinct winery from winemag_p1
where lower(description) regexp "(plum|cherry|rose|hazelnut)([^a-z])"

Question: Find the top 5 businesses with most reviews. Assume that each row has a unique business_id such that the total reviews for each business is listed on each row. Output the business name along with the total number of reviews and order your results by the total reviews in descending order.
Approach: We select the business name and review count columns from the table. We order by the review count column in descending order and limit the result to the top.

select name, review_count from yelp_business
order by review_count desc
limit 5

Question: Find the percentage of shipable orders. Consider an order is shipable if the customer's address is known.
Approach: We first join the customers table to the orders table using a left join using their common column customer id. We then select the proportion of the count of adresses from the customers table and the total number of rows/orders from the orders table. We multiply this by 100 to convert from a decimal.

select (count(c.address)/count(*))*100 from orders o
left join customers c
on o.cust_id = c.id

Question: Calculate the percentage of spam posts in all viewed posts by day. A post is considered a spam if a string "spam" is inside keywords of the post. Note that the facebook_posts table stores all posts posted by users. The facebook_post_views table is an action table denoting if a user has viewed a post.
Approach: We first create a cte in which we join the tables using a left join. This ensures that the results remaining are only posts that have been viewed. Withtin this cte, we also ensure that each post only shows up once by using distinct on the post_id column. Lastly in the cte, we create a new column using the case function in which we asign the number 1 in the case the post is spam and 0 if it is not. From this cte we can extract the desired ratio of spam viewed posts to all viewed posts by post date.

with cte as(
select distinct p.post_id, p.poster, p.post_text, p.post_keywords, p.post_date, 
case when post_keywords like "%spam%" then 1
else 0
end as spam_binary
from facebook_post_views v
left join facebook_posts p
on v.post_id = p.post_id)

select post_date, (sum(spam_binary)/count(*))*100 from cte
group by post_date

Question: Find the number of apartments per nationality that are owned by people under 30 years old. Output the nationality along with the number of apartments. Sort records by the apartments count in descending order.
Approach: We first use a left join to join the two tables on their commonn column host id. We then filter the results using a where clause to unit type apartment and age < 30. We use the count function along with distinct to count unique unit ids to get a count of apartments meeting the specified conditions. We also include the nationality column. We also group by the nationality column to get a count per nationality. Lastly we order by the count descending.

select count(distinct u.unit_id), nationality from airbnb_units u
left join airbnb_hosts h
on u.host_id = h.host_id
where u.unit_type = "Apartment"
and h.age < 30
group by nationality
order by count(distinct u.unit_id) desc

Question: Rank guests based on the total number of messages they've exchanged with any of the hosts. Guests with the same number of messages as other guests should have the same rank. Do not skip rankings if the preceding rankings are identical. Output the rank, guest id, and number of total messages they've sent. Order by the highest number of total messages first.
Approach: Due to the nature of the specified ranking system, we know we will use a dense_rank as opposed to a rank function. We dende rank over the sum of number or messages in descending order and include the id_guest column and sum of messages. We group by the id_guest column in order to get a sum or messages per id. Lastly we order by the number or messages in descending order.
select 
dense_rank() over (order by sum(n_messages) desc) as ranks,
id_guest, sum(n_messages)
from airbnb_contacts
group by id_guest
order by (n_messages) desc

Question: What is the overall friend acceptance rate by date? Your output should have the rate of acceptances by the date the request was sent. Order by the earliest date to latest.
Assume that each friend request starts by a user sending (i.e., user_id_sender) a friend request to another user (i.e., user_id_receiver) that's logged in the table with action = 'sent'. If the request is accepted, the table logs action = 'accepted'. If the request is not accepted, no record of action = 'accepted' is logged.
Approach: We create 2 ctes, one with the sent requests using a where clause and one filtering for the accepted requests. We use a left join to join all the sent requests to the matching acceptances. The rates can be calculated using a count of ids from the accepted cte divided by a count of ids from the sent cte.

with cte1 as(
select user_id_sender, user_id_receiver, date as sent_date, action as action1 from fb_friend_requests
where action = "sent"
),
cte2 as(
select user_id_sender, user_id_receiver, date as accepted_date, action as action2 from fb_friend_requests
where action = "accepted"
)
select count(b.user_id_sender)/count(a.user_id_sender), a.sent_date from cte1 a
left join cte2 b
on a.user_id_sender = b.user_id_sender
and
a.user_id_receiver = b.user_id_receiver
group by a.sent_date

Question: Identify projects that are at risk for going overbudget. A project is considered to be overbudget if the cost of all employees assigned to the project is greater than the budget of the project. You'll need to prorate the cost of the employees to the duration of the project. For example, if the budget for a project that takes half a year to complete is $10K, then the total half-year salary of all employees assigned to the project should not exceed $10K. Salary is defined on a yearly basis, so be careful how to calculate salaries for the projects that last less or more than one year. Output a list of projects that are overbudget with their project name, project budget, and prorated total employee expense (rounded to the next dollar amount). HINT: to make it simpler, consider that all years have 365 days. You don't need to think about the leap years.
Approach: We begin by using a cte to modify the linkedin employee table containing yearly salaries. We convert these to daily salaries by divideing by 365. Next we combine our tables: The employee projects is joined to the projects table using a right join to retain all employees and join with their project numbers. We then join the cte we created with the daily salaries using an inner join. We need to add the employee salaries per project in order to compare with the budgets so we select the project titles and budgets and a ceiling of the sum of daily salaries multiplied by the project lengths which we get by a datediff function. We group by title and budget to get our sum values per project. Lastly, we filter using a having clause in which employee cost is greater than the budget to get our overbudget projects.

with daily_salaries as(
select id, salary/365 as daily_salary from linkedin_employees
)
select 
p.title, p.budget, ceil(sum(ds.daily_salary*datediff(p.end_date, p.start_date))) as employee_cost
from linkedin_projects p
right join linkedin_emp_projects ep
on p.id = ep.project_id
inner join daily_salaries ds
on ep.emp_id = ds.id
group by p.title, p.budget
having ceil(sum(ds.daily_salary*datediff(p.end_date, p.start_date))) > p.budget
order by p.id

Question: You are given a table of product launches by company by year. Write a query to count the net difference between the number of products companies launched in 2020 with the number of products companies launched in the previous year. Output the name of the companies and a net difference of net products released for 2020 compared to the previous year.
Approach: We create 2 ctes with the respective counts for launches per year. One for 2019 and one for 2020. We combine these two ctes with an inner join on company name in our query and take a difference in launch counts.

with 2019_launches as(
select company_name, count(distinct product_name) as 2019_num from car_launches
where year = 2019
group by company_name
),

2020_launches as(
select company_name, count(distinct product_name) as 2020_num from car_launches
where year = 2020
group by company_name
)

select 2019_launches.company_name, 2020_num - 2019_num from 2019_launches
inner join 2020_launches 
on 2019_launches.company_name = 2020_launches.company_name 

Question: Find the email activity rank for each user. Email activity rank is defined by the total number of emails sent. The user with the highest number of emails sent will have a rank of 1, and so on. Output the user, total emails, and their activity rank. Order records by the total emails in descending order. Sort users with the same number of emails in alphabetical order.
In your rankings, return a unique value (i.e., a unique rank) even if multiple users have the same number of emails. For tie breaker use alphabetical order of the user usernames.
Approach: We first create a cte with the number of emails per user using the count and group by functions. Using this cte we can seletct the desired columns, and use the row number window function to number the values ordered by the email counts desc and usernames asc. We lastly order the results in the same way.

with email_counts as(
select from_user, count(*) as num_emails from google_gmail_emails
group by from_user
)
select from_user, num_emails, row_number() over (order by num_emails desc, from_user asc) as activity_rank from email_counts
order by num_emails desc, from_user asc

Question: Calculate each user's average session time. A session is defined as the time difference between a page_load and page_exit. For simplicity, assume a user has only 1 session per day and if there are multiple of the same events on that day, consider only the latest page_load and earliest page_exit, with an obvious restriction that load time event should happen before exit time event . Output the user_id and their average session time.
Approach: We begin by creating two ctes to filter out unnecessary entries from the original table. The first cte is where each session begins, outputting the latest page load per day as our timestamp. The second cte similarly outputs the earliest page load per day. We combine the ctes on user id and date to get a single rows with page loads and exits per day. To get the average sessions, we take a sim of the time differences per session and divide by the number of sessions per user. We group by user in order to get our final result.

with begin_session as (
select user_id, max(timestamp) as latest_load, date(timestamp), action from facebook_web_log
where action = 'page_load'
group by user_id, date(timestamp)
),
end_session as (
select user_id, min(timestamp) as earliest_exit, date(timestamp), action from facebook_web_log
where action = 'page_exit'
group by user_id, date(timestamp)
)
select b.user_id, sum(timestampdiff(second, b.latest_load, e.earliest_exit))/count(b.user_id) as avg_session_time from begin_session b
inner join end_session e
on b.user_id = e.user_id
and date(b.latest_load) = date(e.earliest_exit)
group by b.user_id

Question: You have been asked to find the job titles of the highest-paid employees. Your output should include the highest-paid title or multiple titles with the same salary.
Approach: We join the two tables on their common field worker id. We then set the where condition to the maximum salary from the worker table. We select the title column to output all titles satisfying this condition.

select t.worker_title from worker w
inner join title t
on t.worker_ref_id = w.worker_id
where salary = (select max(salary) from worker)

Question: Find the 3 most profitable companies in the entire world. Output the result along with the corresponding company name. Sort the result based on profits in descending order.
Approach: We select the company and profits columns. We order the results by profits descending and limit to the top 3 results.

select company, profits from forbes_global_2010_2014
order by profits desc
limit 3

Question: Find the average total compensation based on employee titles and gender. Total compensation is calculated by adding both the salary and bonus of each employee. However, not every employee receives a bonus so disregard employees without bonuses in your calculation. Employee can receive more than one bonus. Output the employee title, gender (i.e., sex), along with the average total compensation.
Approach: We first create a cte with the total bnuses per employee. We do this by taking the sum of the bnus column and grouping by worker id. We then join the cte to the employee table using an inner join in order to only include employees with bonuses. We select title, sex and the average of total compensation which is bonus plus salary. WE group by title and sex to get our averages.

with bonus_totals as (
select worker_ref_id, sum(bonus) as tot_bonus from sf_bonus
group by worker_ref_id
)

select e.employee_title, e.sex, avg(b.tot_bonus + e.salary) from sf_employee e
inner join bonus_totals b
on b.worker_ref_id = e.id
group by e.employee_title, e.sex

Hard
Question: Find the popularity percentage for each user on Meta/Facebook. The popularity percentage is defined as the total number of friends the user has divided by the total number of users on the platform, then converted into a percentage by multiplying by 100.
Output each user along with their popularity percentage. Order records in ascending order by user id.
The 'user1' and 'user2' column are pairs of friends.
Approach: We first create a cte combining all the friend pairings so that they repeat per user. We do this by flipping the columns and using the union all operator. We create a second cte to count all users on the platform by counting distinct user1 values. Lastly, our final query consists of selecting the user1 column, and the calculation of all rows (per user 1) divided by total users and multiplied by 100. We group by user 1 to return values per user and order by user ids asc.

with cte as(
SELECT user1, user2
FROM facebook_friends
UNION ALL
SELECT user2, user1
FROM facebook_friends
),

user_count as(
select count(distinct user1) as total_users from cte
)

select user1, (count(*)/(select total_users from user_count))*100 as popularity_percentage from cte
group by user1
order by user1 asc

Question: Select the most popular client_id based on a count of the number of users who have at least 50% of their events from the following list: 'video call received', 'video call sent', 'voice call received', 'voice call sent'.
Approach: We first create a cte in order to categorize the event types into the desired events and non-desired. We do this by selecting the relevant columns and using a case statement to categorize and assign a 1 to desired events and 0 to all others. Using this cte we create a second in order to satisfy the 50% condition. We do this by selecting the relevant columns and setting a having condition to the sum of the selected events from the case statament over total events. We do this per user and include client id. In order to determine the popularity of client ids after satisfying the necessary conditions we take a count of the remaining data per client id. Lastly, we select the top client id from this final cte to get our result.

with cte as (
select client_id, user_id, event_type, 
case
when event_type in ('video call received', 'video call sent', 'voice call received', 'voice call sent') then 1
else 0
end as selected_events
from fact_events
),
cte2 as (
select client_id, user_id from cte
group by client_id, user_id
having sum(selected_events)/count(event_type) >= 0.5
),
cte3 as (
select client_id, count(*) as client_id_count from cte2
group by client_id)

select client_id from cte3
having max(client_id_count)\


Question: Find the total number of downloads for paying and non-paying users by date. Include only records where non-paying customers have more downloads than paying customers. The output should be sorted by earliest date first and contain 3 columns date, non-paying downloads, paying downloads.
Approach: We start by creating ctes seperating the paid accounts from the non paid accounts. We then separate the paying downloads from the non-paying downloads using these previous ctes. Lastly, we combine the downloads tables using the date as our common column and use a where clause to satisfy the condition where non-paying customers have more downloads than paying customers. We order by date (asc by default)

with paying as (
select ud.user_id, ud.acc_id, ad.paying_customer from ms_user_dimension ud
inner join ms_acc_dimension ad
on ud.acc_id = ad.acc_id
where ad.paying_customer = 'yes'
),
non_paying as (
select ud.user_id, ud.acc_id, ad.paying_customer from ms_user_dimension ud
inner join ms_acc_dimension ad
on ud.acc_id = ad.acc_id
where ad.paying_customer = 'no'
),
paying_downloads as (
select df.date, sum(df.downloads) as tot_downloads from ms_download_facts df
inner join paying p
on df.user_id = p.user_id
group by df.date
),
non_paying_downloads as (
select df.date, sum(df.downloads) as tot_downloads from ms_download_facts df
inner join non_paying np
on df.user_id = np.user_id
group by df.date
)

select pd.date, pd.tot_downloads, npd.tot_downloads from paying_downloads pd
inner join non_paying_downloads npd
on pd.date = npd.date
where npd.tot_downloads > pd.tot_downloads
order by date



