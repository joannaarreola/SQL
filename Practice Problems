This file contains a variety of practice problems from different websites. I found these the most helpful in my SQL learning journey as they gave me exposure to a variety of question
types/problems I could encounter as well as new SQL syntax I hadn't used before. I revisit these practice problems to brush up on my SQL skills. The difficulty of the problems is specified in headings.

HackerRank
Easy
Question: Query all columns for all American cities in the CITY table with populations larger than 100000. The CountryCode for America is USA.
Approach: We need to form a select statement with * to select all columns, gather the data from the city table, and filter using a where clause. There are two conditions, so include these both using the and operator.

select * from city
where population > 100000
and countrycode = 'USA'

Question: Query the NAME field for all American cities in the CITY table with populations larger than 120000. The CountryCode for America is USA.
Approach: We need to form a select statement and select the name column, gather the data from the city table, and filter using a where clause. There are two conditions, so include these both using the and operator.

select name from city
where population > 120000
and countrycode = 'USA'

Question: Query all columns (attributes) for every row in the CITY table
Approach: This is a straight forward select statement. We use * to select all the columns from the city table.

select * from city

Question: Query all columns for a city in CITY with the ID 1661.
Approach: We use a select statement with * to include all the columns. We filter using a where clause to the specified numerical value.

select * from city
where ID = 1661

Question: Query all attributes of every Japanese city in the CITY table. The COUNTRYCODE for Japan is JPN.
Approach: We use a select statement with * to include all the columns. We filter using a where clause to the specified countrycode.

select * from city
where countrycode = 'JPN'

Question: Query the names of all the Japanese cities in the CITY table. The COUNTRYCODE for Japan is JPN.
Approach: We can use the same answer from the previous question and modify it to select only the name column rather than all.

select name from city
where countrycode = 'JPN'

Question: Query a list of CITY and STATE from the STATION table.
Approach: This is a straight forward select statement. We select the city and state columns from the station table.

select city, state from station

Question: Query a list of CITY names from STATION for cities that have an even ID number. Print the results in any order, but exclude duplicates from the answer.
Approach: In order to exclude duplicates we use the distinct function. We select the city column from the station table. In order to get even number ids only we can use the modulo operator. The id number divided by 2 should give remainder 0.

select distinct city from station
where mod(id, 2) = 0

Question: Find the difference between the total number of CITY entries in the table and the number of distinct CITY entries in the table.
Approach: We select a count of the city names and subtract from a count of distinct city names from the station table.

select count(city) - count(distinct city) from station

Question: Query the two cities in STATION with the shortest and longest CITY names, as well as their respective lengths (i.e.: number of characters in the name). If there is more than one smallest or largest city, choose the one that comes first when ordered alphabetically.
Approach: We select city name from the station table and use the length function to get the number of letters in the city name. We order the results by length descending to get the longest name and also order by city to sort alphabetically. Limit to the top answer. We use a union to display the shortest city as well. We use the same select statement and change to ascending length.

(select city, length(city) from station
order by length(city) desc, city
limit 1)
union
(select city, length(city) from station
order by length(city) asc, city
limit 1)

Question: Query the list of CITY names starting with vowels (i.e., a, e, i, o, or u) from STATION. Your result cannot contain duplicates.
Approach: We use a distinct clause in order to avoid duplicates. We can match any of the characters in the brackets at the beginning of the string using an rlike expression, ^, and [].

select distinct city from station
where city RLIKE '^[AEIOU]'

Question: Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot contain duplicates.
Approach: We use a distinct clause in order to avoid duplicates. We can match any of the characters in the brackets at the end of the string using an rlike expression, $, and [].

select distinct city from station
where city RLIKE '[aeiou]$'

Question: Query the list of CITY names from STATION which have vowels (i.e., a, e, i, o, and u) as both their first and last characters. Your result cannot contain duplicates.
Approach: We can combine some of the previous select statements from previous questions with an and operator in order to satisfy both conditions.

select distinct city from station
where city rlike '^[AEIOU]' and city rlike '[aeiou]$'

Question: Query the list of CITY names from STATION that do not start with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the first letter and add not to the rlike operator in order to search for the opposite.

select distinct city from station
where city not RLIKE '^[AEIOU]'

Question: Query the list of CITY names from STATION that do not end with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the last letter and add not to the rlike operator in order to search for the opposite.

select distinct city from station
where city not RLIKE '[aeiou]$'

Question: Query the list of CITY names from STATION that either do not start with vowels or do not end with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the first and last letter and add not to the rlike operator in order to search for the opposite. We also edit the epression to or instead of and to serach for either.

select distinct city from station
where city not rlike '^[AEIOU]' or city not rlike '[aeiou]$'

Question: Query the list of CITY names from STATION that do not start with vowels and do not end with vowels. Your result cannot contain duplicates.
Approach: We can use the previous select statement searching for results containing vowels in the first and last letter and add not to the rlike operator in order to search for the opposite.

select distinct city from station
where city not rlike '^[AEIOU]' and city not rlike '[aeiou]$'

Question: Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
Approach: We select the column name from the table students. We filter to marks greater than 75. To order by the last 3 characters of the names we use the substring function specifying the name column, the third to last position of the string, and 3 characters from this position i the string. We then order by ascending id.

select name from students
where marks > 75
order by substring(name, -3, 3), id asc

Question: Write a query that prints a list of employee names (i.e.: the name attribute) from the Employee table in alphabetical order.
Approach: We select the name column from the employee table. We then order by name to put the names in alphabetical order.

select name from employee
order by name

Question: Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.
Approach: We select the name column from the employee table. We filter to salary over 2000 and months less than 10. We lastly order by ascending employee id.

select name from employee
where salary > 2000
and months < 10
order by employee_id asc

Question: Write a query identifying the type of each record in the TRIANGLES table using its three side lengths. Output one of the following statements for each record in the table:
Equilateral: It's a triangle with 3 sides of equal length.
Isosceles: It's a triangle with 2 sides of equal length.
Scalene: It's a triangle with 3 sides of differing lengths.
Not A Triangle: The given values of A, B, and C don't form a triangle.
Approach: We use a case statement in order to create a new column and print the desired text. The case statement conditions are evaluated in order so we should first determine if the sides even make up a triangle. From there we can test if all sides are equal, then if two sides are equal, or if none are equal.

SELECT
  CASE 
    WHEN A + B <= C or A + C <= B or B + C <= A THEN 'Not A Triangle'
    WHEN A = B and B = C THEN 'Equilateral'
    WHEN A = B or A = C or B = C THEN 'Isosceles'
    WHEN A <> B and B <> C THEN 'Scalene'
  END AS triangle_type
FROM TRIANGLES;

Question: Query a count of the number of cities in CITY having a Population larger than 100,000
Approach: We use the count(*) function to count the total number of results. We then filter the population number using a where clause.

select count(*) from city
where population > 100000

Question: Query the total population of all cities in CITY where District is California.
Approach: We use the count function and specify the population column in order to get the aggregate population. We filter the district to California using a where clause.

select sum(population) from city
where district = 'California'

Question: Query the average population of all cities in CITY where District is California.
Approach: We can use the select statement from the previous question and change the sum function to the avergae function instead.

select avg(population) from city
where district = 'California'

Question: Query the average population for all cities in CITY, rounded down to the nearest integer.
Approach: We use the average function to get the average population from the city table. We use the floor funtion on the average function to round down to the nearest integer.

select floor(avg(population)) from city

Questiion: Query the sum of the populations for all Japanese cities in CITY. The COUNTRYCODE for Japan is JPN
Approach: We use the sum function and specify the population column in order to get the aggregate population. We filter the countrycode to Japan using a where clause.

select sum(population) from city
where countrycode = 'JPN'

Question: Query the difference between the maximum and minimum populations in CITY.
Approach: We use the max and min functions ad specify the population column. We subtract these from each other to obtain our result.

select max(population) - min(population) from city

Question: Samantha was tasked with calculating the average monthly salaries for all employees in the EMPLOYEES table, but did not realize her keyboard's  key was broken until after completing the calculation. She wants your help finding the difference between her miscalculation (using salaries with any zeros removed), and the actual average salary. Write a query calculating the amount of error (i.e.:  average monthly salaries), and round it up to the next integer.
Approach: We start by using av(salary) to get the actual result. In order to achieve the result of the miscalculation we need to replace every instance of 0 with an empty value. We do this by using the replace function. We then subract these two results (actual and miscalculation) and use the ceil function to round up.

select ceil(avg(salary) - avg(replace(salary, 0, ''))) from employees

Question: We define an employee's total earnings to be their monthly salary * months worked, and the maximum total earnings to be the maximum total earnings for any employee in the Employee table. Write a query to find the maximum total earnings for all employees as well as the total number of employees who have maximum total earnings. Then print these values as 2 space-separated integers.
Approach: We use the max function of months*salary to get the maximum value of total earnings. We use a count(*) function to determine the total number of employees with the max total_earnings as their total earnings. We use a subquery in order to specify the value we want the count to retrieve.

SELECT MAX(months * salary), COUNT(*) 
FROM employee
WHERE months * salary = (SELECT MAX(months * salary) FROM employee)

Question: Query the following two values from the STATION table:
The sum of all values in LAT_N rounded to a scale of 2 decimal places.
The sum of all values in LONG_W rounded to a scale of 2 decimal places.
Approach: we use the round function on the sum of latitude and longitude values to round the results to 2 decimal places.

select round(sum(lat_n), 2), round(sum(long_w), 2) from station

Question: Query the sum of Northern Latitudes (LAT_N) from STATION having values greater than 38.7880 and less than 137.2345. Truncate your answer to  decimal places.
Approach: We use the truncate function on the sum of lat_n to truncate the answer to 4 decimal places. We use the between operator in order to specify the numeric boundaries.

select truncate(sum(lat_n), 4) from station
where lat_n between 38.7880 and 137.2345

Question: Query the greatest value of the Northern Latitudes (LAT_N) from STATION that is less than 137.2345. Truncate your answer to 4 decimal places.
Approach: We use the truncate function on lat_n to truncate the answer to 4 decimal places. We use a where clause in order to filter the results to less than 137.2345. We then order the results by descending lat_n and limit to 1 in order to get the top value.

select truncate(lat_n, 4) from station
where lat_n < 137.2345
order by lat_n desc
limit 1

Question: Query the Western Longitude (LONG_W) for the largest Northern Latitude (LAT_N) in STATION that is less than 137.2345. Round your answer to 4 decimal places.
Approach: We use the round function on long_w to round the answer to 4 decimal places. We use a where clause in order to filter the results to lat_n less than 137.2345. We then order the results by descending lat_n and limit to 1 in order to get the top value.

select round(long_w, 4) from station
where lat_n < 137.2345
order by lat_n desc
limit 1

Question: Query the smallest Northern Latitude (LAT_N) from STATION that is greater than 38.7780. Round your answer to 4 decimal places.
Approach: We use the round function on lat_n to round the answer to 4 decimal places. We use a where clause in order to filter the results to greater than 38.7780. We then order the results by ascending lat_n and limit to 1 in order to get the smallest value.

select round(lat_n, 4) from station
where lat_n > 38.7780
order by lat_n asc
limit 1

Question: Query the Western Longitude (LONG_W)where the smallest Northern Latitude (LAT_N) in STATION is greater than 38.7780. Round your answer to 4 decimal places.
Approach: We use the round function on long_w to round the answer to 4 decimal places. We use a where clause in order to filter the results to greater than 38.7780. We then order the results by ascending lat_n and limit to 1 in order to get the smallest value.

select round(long_w, 4) from station
where lat_n > 38.7780
order by lat_n asc
limit 1

Question: Given the CITY and COUNTRY tables, query the sum of the populations of all cities where the CONTINENT is 'Asia'.
Approach: We need to join the city and country tables in order to use data from both tables. We select the sum of population specifying it is from the city table. We use an inner join in order to match values in both the city and country tables. We join on their common column country code. Lastly, we filter the results using a where clause and set the continent to Asia.

select sum(city.population) from city
inner join country on city.countrycode = country.code
where country.continent = 'Asia'

Question: Given the CITY and COUNTRY tables, query the names of all cities where the CONTINENT is 'Africa'.
Approach: We need to join the city and country tables in order to use data from both tables. We select the name column specifying it is from the city table. We use an inner join in order to match values in both the city and country tables. We join on their common column country code. Lastly, we filter the results using a where clause and set the continent to Africa.

select city.name from city
inner join country on city.countrycode = country.code
where country.continent = 'Africa'

Question: Given the CITY and COUNTRY tables, query the names of all the continents (COUNTRY.Continent) and their respective average city populations (CITY.Population) rounded down to the nearest integer.
Approach: We need to join the city and country tables in order to use data from both tables. We select the contient column specifying it is from the country table. We also select the average population specifying it is from the city table and use the floor function on this result in order to round down to the nearest integer. We use an inner join in order to match values in both the city and country tables. We join on their common column country code. Lastly, we group by country.continent to specify the average aggregations.

select country.continent, floor(avg(city.population)) from city
inner join country on city.countrycode = country.code
group by country.continent

Medium
Question: Generate the following two result sets:

Query an alphabetically ordered list of all names in OCCUPATIONS, immediately followed by the first letter of each profession as a parenthetical (i.e.: enclosed in parentheses). For example: AnActorName(A), ADoctorName(D), AProfessorName(P), and ASingerName(S).
Query the number of ocurrences of each occupation in OCCUPATIONS. Sort the occurrences in ascending order, and output them in the following format:

There are a total of [occupation_count] [occupation]s.
where [occupation_count] is the number of occurrences of an occupation in OCCUPATIONS and [occupation] is the lowercase occupation name. If more than one Occupation has the same [occupation_count], they should be ordered alphabetically.
Approach: For the first result set, we use the concatenate function to print out the name, parenthesis, and use the substring function to extract the first letter in the occupation column. We use an alias N for this concatenated string in order to sort later since using a union will order the entire result set when an order by function is used. We use a union and move on the the next result set. For this result we again use the concatenated function to print out the given string, then a count of each occupation, a space, the occupation in lowercase, and an s. We also use the alias N for sorting purposes. We group by occupation since we used the count function. Lastly, we sort the entire union by N asc. This will sort the first part alphabetically and the second part numerically ascending.

(select concat(name, '(', substr(Occupation,1,1), ')') as N from occupations)
union
(select concat('There are a total of ', count(occupation), ' ', lower(occupation), 's.') as N from occupations
group by occupation)

order by N asc

Question: Amber's conglomerate corporation just acquired some new companies. Each of the companies follows this hierarchy: Founder > Lead Manager > Senior Manager > Manager > Employee. Given the table schemas below, write a query to print the company_code, founder name, total number of lead managers, total number of senior managers, total number of managers, and total number of employees. Order your output by ascending company_code.
Approach: After browsing the table schemas we notice that The employee and company tables include all the data we need. The rest of the tables contain redundant information. We select company_code from the employee table, founder name from the company table, a count of the distinct lead manager codes from the employee table, a count of the distinct senior manager codes from the employee table, a count of the distinct manager codes from the employee table, and a count of the distinct employee codes from the employee table. We inner join on company_code to join the employee and company tables using the aliases e and c respectively. We gorup by company code and founder since these are out non-aggregates. Lastly, we order by ascending company code.

select 
e.company_code, 
c.founder, 
count(distinct e.lead_manager_code), 
count(distinct e.senior_manager_code), 
count(distinct e.manager_code), 
count(distinct e.employee_code) 
from employee e
inner join company c 
on e.company_code = c.company_code
group by e.company_code, c.founder
order by e.company_code asc

Question: You are given a table, BST, containing two columns: N and P, where N represents the value of a node in Binary Tree, and P is the parent of N. Write a query to find the node type of Binary Tree ordered by the value of the node. Output one of the following for each node:
Root: If node is root node.
Leaf: If node is leaf node.
Inner: If node is neither root nor leaf node.
Approach: In order to satisfy the desired output, we will need the value of n, whether the node is a root, leaf or inner, ordered by n. To do this we first select n. Then we construct a case statement. We can start with the simplest condition which is for a root node. If the value of P is null (no parent node), the node is a root. Next, if the node is an inner node the value of n will also be inside p because the node can also be a parent node. All other values of n will be considered leaves.

select n,
case 
when p is null then 'Root'
when n in(select p from bst) then 'Inner'
else 'Leaf'
end as 'type of node'
from bst
order by n

Question: Consider P1 and P2 to be two points on a 2D plane.
 a happens to equal the minimum value in Northern Latitude (LAT_N in STATION).
 b happens to equal the minimum value in Western Longitude (LONG_W in STATION).
 c happens to equal the maximum value in Northern Latitude (LAT_N in STATION).
 d happens to equal the maximum value in Western Longitude (LONG_W in STATION).
Query the Manhattan Distance between points P1 and P2 and round it to a scale of 4 decimal places.
Approach: The formula for Manhattan Distance is |x1 - x2| + |y1 - y2|. We can replace these values with our given ones to get |a - c| + |b - d|. We then plug in the values to get |min(lat_n) - max(lat_n)| + |min(long_w) - max(long_w)|. In order to input to sql we use the abs() function. Lastly we use the round function to round to 4 decimal places.

select round((abs(min(lat_n)-max(lat_n)) + abs(min(long_w)-max(long_w))),4) from station

Question:
Consider p1(a,c) and p2(b,d) to be two points on a 2D plane where (a,b) are the respective minimum and maximum values of Northern Latitude (LAT_N) and (b,d) are the respective minimum and maximum values of Western Longitude (LONG_W) in STATION. Query the Euclidean Distance between points p1 and p2 and format your answer to display 4 decimal digits.
Approach: The formula for Euclidean Distance is sqrt((q1-p1)^2 + (q2-p2)^2). We can replace these values with our given ones to get sqrt((b-a)^2 + (d-c)^2). We then plug in the values to get sqrt((max lat_n-min lat_n)^2 + (max long_w-min long_w)^2). In order to input to sql we use the power() and sqrt() functions. Lastly we use the round function to round to 4 decimal places.

select round((sqrt(
power((max(lat_n) - min(lat_n)), 2) +
power((max(long_w) - min(long_w)),2)
    )), 4)
from station

Question: A median is defined as a number separating the higher half of a data set from the lower half. Query the median of the Northern Latitudes (LAT_N) from STATION and round your answer to 4 decimal places.
Approach: We first need to order the lat_n values. To do this, we can use a cte which we will name in_order. Within this cte, we select the let_n column and window functions to add numbered columns for both ascending lat_n and descending lat_n. Our goal with this is to find the matching column number of the ascending and descending values, or the average if there is an even number or values. To do this, we select from the cte the averge lat_n rounded to 4 decimal places that satisfies the condition ascending row number = descending row number, or one above or below. This should give us our median value. 

with in_order as (
SELECT lat_n,
ROW_NUMBER() OVER (ORDER BY lat_n) AS RowAsc,
ROW_NUMBER() OVER (ORDER BY lat_n DESC) AS RowDesc
FROM station
)

SELECT round((AVG(lat_n)), 4) AS median
FROM in_order
WHERE RowAsc = RowDesc OR RowAsc + 1 = RowDesc OR RowAsc = RowDesc + 1;

Question: You are given two tables: Students and Grades. Students contains three columns ID, Name and Marks. Ketty gives Eve a task to generate a report containing three columns: Name, Grade and Mark. Ketty doesn't want the NAMES of those students who received a grade lower than 8. The report must be in descending order by grade -- i.e. higher grades are entered first. If there is more than one student with the same grade (8-10) assigned to them, order those particular students by their name alphabetically. Finally, if the grade is lower than 8, use "NULL" as their name and list them by their grades in descending order. If there is more than one student with the same grade (1-7) assigned to them, order those particular students by their marks in ascending order. Write a query to help Eve.
Approach: Because we want to treat 2 result sets differently, we know we will use a case statement. The condition we will use is grade < 8 to print null. Otherwise, the student's name will be printed. We specify the end as columns name, grade, and marks. The name column is not the same as s.name since we are using the nulls, so we just say 'name'. We use an inner join to join the students table to the grades table. Since the grades table has a range of values within 2 columns we use between in our on condition. Lastly, we order by grade descending, then by name alphabetically, then by ascending marks.

select 
case 
when g.grade < 8 then null
else s.name
end as name, g.grade, s.marks from students s
inner join grades g 
on s.marks between g.min_mark and g.max_mark
order by g.grade desc, s.name, s.marks asc

Question: Julia just finished conducting a coding contest, and she needs your help assembling the leaderboard! Write a query to print the respective hacker_id and name of hackers who achieved full scores for more than one challenge. Order your output in descending order by the total number of challenges in which the hacker earned a full score. If more than one hacker received full scores in same number of challenges, then sort them by ascending hacker_id.
Approach: We first select hacker_id from the submissions table and name from the hackers table. We will need to join all the tables on common columns. To filter for full scores, we need to make sure the score earned by the hacker in the submissions table is the same as the total possible score from tthe difficulty table and also that the score pertains to the difficulty level for that particular challenge. We group by hacker_id and name to narrow to one row per hacker and use a count function to filter to those gaining a full score in more than 1 challenge. Lastly, we order by the number of challenges and by hacker_id.

select s.hacker_id, h.name from submissions s
inner join hackers h
on h.hacker_id = s.hacker_id
inner join challenges c
on c.challenge_id = s.challenge_id
inner join difficulty d
on d.difficulty_level = c.difficulty_level
where d.score = s.score and d.difficulty_level = c.difficulty_level
group by s.hacker_id, h.name
having count(h.name) > 1
order by count(h.name) desc, s.hacker_id

